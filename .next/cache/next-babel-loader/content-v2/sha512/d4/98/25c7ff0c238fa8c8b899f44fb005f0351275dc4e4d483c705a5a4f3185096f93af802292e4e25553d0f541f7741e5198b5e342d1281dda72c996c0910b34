{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nimport { getType } from 'deox';\nimport { uiActions } from '../../actions';\n\nconst successReducer = (state = {}, action) => {\n  if (action.type === getType(uiActions.resetActionStatus)) {\n    const {\n      actionName\n    } = action.payload;\n\n    const {\n      [actionName]: _\n    } = state,\n          newState = _objectWithoutProperties(state, [actionName].map(_toPropertyKey));\n\n    return newState;\n  }\n\n  const matches = /(.*)_(REQUEST|SUCCESS)/.exec(action.type);\n  if (!matches) return state;\n  const [, requestName, requestStatus] = matches;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    [requestName]: requestStatus === 'SUCCESS'\n  });\n};\n\nexport default successReducer;","map":{"version":3,"sources":["/Users/admin/Documents/personal-site/src/state-management/reducers/status/success.ts"],"names":["getType","uiActions","successReducer","state","action","type","resetActionStatus","actionName","payload","_","newState","matches","exec","requestName","requestStatus"],"mappings":";;;;;;;;;;;;;;AAAA,SAASA,OAAT,QAAwB,MAAxB;AAEA,SAASC,SAAT,QAA0B,eAA1B;;AAgBA,MAAMC,cAAc,GAAG,CAACC,KAAoB,GAAG,EAAxB,EAA4BC,MAA5B,KAAqF;AAC1G,MAAIA,MAAM,CAACC,IAAP,KAAgBL,OAAO,CAACC,SAAS,CAACK,iBAAX,CAA3B,EAA0D;AACxD,UAAM;AAAEC,MAAAA;AAAF,QAAkBH,MAAD,CAAyBI,OAAhD;;AACA,UAAM;AAAE,OAACD,UAAD,GAAcE;AAAhB,QAAmCN,KAAzC;AAAA,UAA4BO,QAA5B,4BAAyCP,KAAzC,GAASI,UAAT;;AACA,WAAOG,QAAP;AACD;;AAED,QAAMC,OAAO,GAAG,yBAAyBC,IAAzB,CAA8BR,MAAM,CAACC,IAArC,CAAhB;AAEA,MAAI,CAACM,OAAL,EAAc,OAAOR,KAAP;AAEd,QAAM,GAAGU,WAAH,EAAgBC,aAAhB,IAAiCH,OAAvC;AACA,yCACKR,KADL;AAEE,KAACU,WAAD,GAAeC,aAAa,KAAK;AAFnC;AAID,CAhBD;;AAkBA,eAAeZ,cAAf","sourcesContent":["import { getType } from 'deox';\n\nimport { uiActions } from '../../actions';\n\nexport type TSuccessState = { [id: string]: boolean };\n\ninterface ISuccessAction {\n  type: string;\n  payload?: string;\n}\n\ninterface IResetAction {\n  type: string;\n  payload: {\n    actionName: string;\n  };\n}\n\nconst successReducer = (state: TSuccessState = {}, action: ISuccessAction | IResetAction): TSuccessState => {\n  if (action.type === getType(uiActions.resetActionStatus)) {\n    const { actionName } = (action as IResetAction).payload;\n    const { [actionName]: _, ...newState } = state;\n    return newState;\n  }\n\n  const matches = /(.*)_(REQUEST|SUCCESS)/.exec(action.type);\n\n  if (!matches) return state;\n\n  const [, requestName, requestStatus] = matches;\n  return {\n    ...state,\n    [requestName]: requestStatus === 'SUCCESS',\n  };\n};\n\nexport default successReducer;\n"]},"metadata":{},"sourceType":"module"}